<%- include('includes/head.ejs') %>
    <br>
    <input type="hidden" id="epic_Link" value="<%= tickets[0].epic_Link %>">
    <div>

      <!--Dentro de este div no se debe mover nada, está hecho para que automáticamente se acomode el despliegue dependiendo de
          como esté acomodada la ventana. Es un ajuste automático. Todo lo relacionado a los datos debe moverse en el js-->
        <a style="margin-left: 15px;" href='/homepage' class="btn btn-secondary float-right">Return
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-arrow-return-left" viewBox="0 0 16 16">
                <path fill-rule="evenodd" d="M14.5 1.5a.5.5 0 0 1 .5.5v4.8a2.5 2.5 0 0 1-2.5 2.5H2.707l3.347 3.346a.5.5 0 0 1-.708.708l-4.2-4.2a.5.5 0 0 1 0-.708l4-4a.5.5 0 1 1 .708.708L2.707 8.3H12.5A1.5 1.5 0 0 0 14 6.8V2a.5.5 0 0 1 .5-.5z"/>
            </svg>
        </a>
        <div class="d-flex justify-content-between align-items-center px-4">
            <p class="mr-auto mb-0"><h1>Dashboard</h1></p>
        </div>      
        <div class="d-flex justify-content-between align-items-center px-4">
            <p class="mr-auto mb-0"><h2><%= tickets[0].epic_Link_Summary %></h2></p>
            <p class="mr-auto mb-0"><h2></h2></p>
            <p class="ml-auto mb-0">
                <h4>
                    <figure>
                      <figcaption>Team members</figcaption>
                    <img src="https://www.necesitomas.com/files/cuadrantealista03.png" alt="Descripción de la imagen">
                    
                    </figure>
                </h4>
            </p>
        </div>
        <div class="d-flex justify-content-between align-items-center px-5" id="no-data">

            <canvas id="Burnup" width="auto" height="auto" style="margin: 15%"></canvas>

            <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
            
        </div>
    </div>
    </div> 
    <script>
    window.addEventListener('load', () => {
        // Función que manda petición asíncrona cuando se carga o recarga la pag
        let id = document.getElementById("epic_Link").value;
        
        fetch('/epics/dashboard/' + id, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
            }
        }).then(result => {
            return result.json(); 
        }).then(datas => {
        
        // SPRINTS 

            // Calcula los sprints (por semana) 
            let _sprints = [];
            for (let i = 0; i <= Math.ceil(datas.tickets[0].sprints)+1; i++) {
                _sprints.push(i);
            }
            
            // Validar si la gráfica tendrá sentido (Mínimo 2 sprints)
            if(_sprints.length > 1){
        
        // SCOPE

                // Hacer un arreglo con todas las fechas de Update por ticket
                let ticket_Updates = [];
                for(let i = 0; i < datas.tickets.length; i++){
                    ticket_Updates.push(datas.tickets[i].ticket_Update);
                }; // Añadir al arreglo la fecha de creación del epic de los tickets
                   // para usarlo como la mínima fecha (hasta que sea actualizada manualmente por usuario)
                ticket_Updates.push(datas.tickets[0].created_at);

                // Función para encontrar el índice de la fecha mínima entre
                // las updates por ticket y la created_at del epic correspondiente
                function findMinTimestampIndex(dataArray) {
                    let minIndex = 0;
                    let minTimestamp = new Date(dataArray[0]).getTime();
                    for (let i = 1; i < dataArray.length; i++) {
                        let currentTimestamp = new Date(dataArray[i]).getTime();
                        if (currentTimestamp < minTimestamp) {
                            minIndex = i;
                            minTimestamp = currentTimestamp;
                        }
                    }
                    return minIndex;
                }

                // Asignar a sprint_0 la fecha más baja
                let sprint_0 = ticket_Updates[findMinTimestampIndex(ticket_Updates)];
                
                // Crear el objeto scope con un atributo por sprint para 'mapear' los datos
                const scope = {}; 
                for(let sprint of _sprints){
                    scope[sprint] = [];
                }

                // Eliminar created_at para calcular los tickets
                // que habrá por sprint y que no se considere la fecha de creación
                ticket_Updates.pop();
                let j = 0;
                // Calcular los tickets que hay por sprint y asociarlos, por índice a su sprint correspondiente
                for(let ticket_Update of ticket_Updates){
                    let current_Up = new Date(ticket_Update).getTime();
                    // Calcula el tiempo que ha pasado entre cada fecha y la fecha de inicio (↓↓↓ en termino de semanas)
                    let calculo = Math.floor((current_Up - new Date(sprint_0).getTime()) / (1000 * 60 * 60 * 24 * 7))+1;
                    scope[calculo].push(j);
                    j++;
                    }
                scope[0] = scope[1];

                scopes = [];
                // Función para calcular Story Points (SP) por sprint
                for(let _scopes in scope){
                    let suma = 0;
                    for(let i = 0; i < scope[_scopes].length;i++){ 
                        suma += datas.tickets[scope[_scopes][i]].Story_Points;
                    }
                    scopes.push(suma);
                } console.log(scopes);

        // GOAL
                
                let goal = [];
                for(let i = 0; i <= _sprints.length; i++){
                    goal[i] = ((datas.tickets[0].totalSP / (_sprints.length-1))*i);
                } console.log(goal);
        
        // DONE

                const done = [0];
                for(let finished of datas.done){
                    let current_Up = new Date(finished.ticket_Update).getTime();
                    // Calcula el tiempo que ha pasado entre cada fecha y la fecha de inicio (↓↓↓ en termino de semanas)
                    console.log((current_Up - new Date(sprint_0).getTime()) / (1000 * 60 * 60 * 24 * 7));
                    let calculo = Math.floor((current_Up - new Date(sprint_0).getTime()) / (1000 * 60 * 60 * 24 * 7))+1;
                    done[calculo] = done[calculo] || 0;
                    done[calculo] += finished.Story_Points;
                }; 
                
                for(let i = 0;i<done.length;i++){
                    if(done[i] === undefined)
                        done[i] = done[i-1];
                }
                
                console.log(done);

                let miCanvas = document.getElementById("Burnup").getContext("2d");
                const data = {
                    type:'line',
                    data:{
                        labels: _sprints,
                        datasets:[
                            {
                                label: "Scope",
                                data: scopes,
                                backgroundColor:['rgb(0,0,0,.10)'],
                                borderColor:['rgb(0,0,0)'],
                                borderWidth: 3
                            },
                            {   
                                label: "Goal",
                                data: goal,
                                backgroundColor:['rgb(40, 40, 222,.20)'],
                                borderColor:['rgb(40, 40, 222)'],
                                borderWidth: 2
                            },
                            {
                                label:"Done",
                                data: done,
                                backgroundColor:['rgb(25, 250, 0,.30)'],
                                borderColor:['rgb(25, 250, 0)'],
                                borderWidth: 2,
                                borderCapStyle: 'round',
                            }
                        
                            
                        ]
                    },
                    options:{
                        plugins:{
                            legend: {position:'bottom',}
                        },
                        scales:{
                            y:{
                                beginAtZero:true,
                                title: {
                                    display: true,
                                    text: 'Story Points',
                                    color: 'black',
                                    font: {
                                        size: 20,
                                        weight: 'bold'
                                    }
                                }
                            },
                            x:{
                                grid: {
                                    display: false
                                },
                                title: {
                                    display: true,
                                    text: 'Sprint',
                                    color: 'black',
                                    font: {
                                        size: 20,
                                        weight: 'bold'
                                    }
                                }
                            },
                        }
                    }
                }
                var chart = new Chart(miCanvas, data)
            } else {
                document.getElementById("no-data").innerHTML = '<h1> No hay suficientes datos para graficar </h1>';
            }
        }).catch(err =>{console.log(err);});
        
})
    
    </script>
    <!-- <%- include('includes/chart.ejs')%> -->
    <%- include('includes/foot.ejs') %>